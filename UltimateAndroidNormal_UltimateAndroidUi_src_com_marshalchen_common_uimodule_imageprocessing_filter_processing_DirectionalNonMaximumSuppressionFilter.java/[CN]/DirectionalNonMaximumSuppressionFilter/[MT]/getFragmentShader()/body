{
  return "precision mediump float;\n" + "uniform sampler2D " + UNIFORM_TEXTURE0 + ";\n"+ "varying vec2 "+ VARYING_TEXCOORD+ ";\n"+ "uniform float "+ UNIFORM_TEXELWIDTH+ ";\n"+ "uniform float "+ UNIFORM_TEXELHEIGHT+ ";\n"+ "uniform float "+ UNIFORM_UPPER_THRESHOLD+ ";\n"+ "uniform float "+ UNIFORM_LOWER_THRESHOLD+ ";\n"+ "void main(){\n"+ "   vec3 currentGradientAndDirection = texture2D("+ UNIFORM_TEXTURE0+ ","+ VARYING_TEXCOORD+ ").rgb;\n"+ "   vec2 gradientDirection = ((currentGradientAndDirection.gb * 2.0) - 1.0) * vec2("+ UNIFORM_TEXELWIDTH+ ", "+ UNIFORM_TEXELHEIGHT+ ");\n"+ "   float firstSampledGradientMagnitude = texture2D("+ UNIFORM_TEXTURE0+ ","+ VARYING_TEXCOORD+ " + gradientDirection).r;\n"+ "   float secondSampledGradientMagnitude = texture2D("+ UNIFORM_TEXTURE0+ ","+ VARYING_TEXCOORD+ " - gradientDirection).r;\n"+ "   float multiplier = step(firstSampledGradientMagnitude, currentGradientAndDirection.r);\n"+ "   multiplier = multiplier * step(secondSampledGradientMagnitude, currentGradientAndDirection.r);\n"+ "   float thresholdCompliance = smoothstep("+ UNIFORM_LOWER_THRESHOLD+ ", "+ UNIFORM_UPPER_THRESHOLD+ ", currentGradientAndDirection.r);\n"+ "   multiplier = multiplier * thresholdCompliance;\n"+ "   gl_FragColor = vec4(vec3(multiplier), 1.0);\n"+ "}\n";
}
